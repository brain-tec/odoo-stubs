import datetime
from typing import Any, Generic, Optional, TypeVar, overload

from .models import BaseModel
from .tools import date_utils

_FieldT = TypeVar("_FieldT", bound=Field)
_FieldValueT = TypeVar("_FieldValueT")

DATE_LENGTH: Any
DATETIME_LENGTH: Any
EMPTY_DICT: Any
RENAMED_ATTRS: Any
Default: Any

def copy_cache(records, env) -> None: ...
def first(records): ...
def resolve_mro(model, name, predicate): ...

class MetaField(type):
    by_type: Any
    def __new__(meta, name, bases, attrs): ...
    def __init__(cls, name, bases, attrs) -> None: ...

class Field(Generic[_FieldValueT], metaclass=MetaField):
    type: Any
    relational: bool
    translate: bool
    column_type: Any
    column_format: str
    column_cast_from: Any
    args: Any
    def __init__(self, string=..., **kwargs) -> None: ...
    def new(self, **kwargs): ...
    def __getattr__(self, name): ...
    def __setattr__(self, name, value) -> None: ...
    def set_all_attrs(self, attrs) -> None: ...
    def __delattr__(self, name) -> None: ...
    def setup_base(self, model, name) -> None: ...
    prefetch: bool
    string: Any
    default: Any
    def setup_full(self, model) -> None: ...
    depends: Any
    related: Any
    related_field: Any
    compute: Any
    inverse: Any
    search: Any
    states: Any
    required: bool
    def traverse_related(self, record): ...
    @property
    def base_field(self): ...
    def resolve_deps(self, model, path0=..., seen: Any = ...): ...
    recursive: bool
    def setup_triggers(self, model) -> None: ...
    def get_description(self, env): ...
    def null(self, record): ...
    def convert_to_column(
        self, value, record, values: Optional[Any] = ..., validate: bool = ...
    ): ...
    def convert_to_cache(self, value, record, validate: bool = ...): ...
    def convert_to_record(self, value, record): ...
    def convert_to_read(self, value, record, use_name_get: bool = ...): ...
    def convert_to_write(self, value, record): ...
    def convert_to_onchange(self, value, record, names): ...
    def convert_to_export(self, value, record): ...
    def convert_to_display_name(self, value, record): ...
    def update_db(self, model, columns): ...
    def update_db_column(self, model, column) -> None: ...
    def update_db_notnull(self, model, column) -> None: ...
    def update_db_index(self, model, column) -> None: ...
    def read(self, records): ...
    def create(self, record_values) -> None: ...
    def write(self, records, value): ...
    @overload
    def __get__(self, record: BaseModel, owner) -> _FieldValueT: ...
    @overload
    def __get__(self: _FieldT, record: None, owner) -> _FieldT: ...
    def __set__(self, record, value) -> None: ...
    def compute_value(self, records) -> None: ...
    def determine_value(self, record) -> None: ...
    def determine_draft_value(self, record): ...
    def determine_inverse(self, records) -> None: ...
    def determine_domain(self, records, operator, value): ...
    def modified_draft(self, records): ...

class Boolean(Field[bool]):
    type: str
    column_type: Any
    def convert_to_column(
        self, value, record, values: Optional[Any] = ..., validate: bool = ...
    ): ...
    def convert_to_cache(self, value, record, validate: bool = ...): ...
    def convert_to_export(self, value, record): ...

class Integer(Field[int]):
    type: str
    column_type: Any
    def convert_to_column(
        self, value, record, values: Optional[Any] = ..., validate: bool = ...
    ): ...
    def convert_to_cache(self, value, record, validate: bool = ...): ...
    def convert_to_read(self, value, record, use_name_get: bool = ...): ...
    def convert_to_export(self, value, record): ...

class Float(Field[float]):
    type: str
    column_cast_from: Any
    def __init__(self, string=..., digits=..., **kwargs) -> None: ...
    @property
    def column_type(self): ...
    @property
    def digits(self): ...
    def convert_to_column(
        self, value, record, values: Optional[Any] = ..., validate: bool = ...
    ): ...
    def convert_to_cache(self, value, record, validate: bool = ...): ...
    def convert_to_export(self, value, record): ...

class Monetary(Field[float]):
    type: str
    column_type: Any
    column_cast_from: Any
    def __init__(self, string=..., currency_field=..., **kwargs) -> None: ...
    currency_field: str
    def convert_to_column(
        self, value, record, values: Optional[Any] = ..., validate: bool = ...
    ): ...
    def convert_to_cache(self, value, record, validate: bool = ...): ...
    def convert_to_read(self, value, record, use_name_get: bool = ...): ...
    def convert_to_write(self, value, record): ...

class _String(Field[str]):
    def __init__(self, string=..., **kwargs) -> None: ...
    prefetch: Any
    def get_trans_terms(self, value): ...
    def get_trans_func(self, records): ...
    def check_trans_value(self, value): ...

class Char(_String):
    type: str
    column_cast_from: Any
    @property
    def column_type(self): ...
    def update_db_column(self, model, column) -> None: ...
    def convert_to_column(
        self, value, record, values: Optional[Any] = ..., validate: bool = ...
    ): ...
    def convert_to_cache(self, value, record, validate: bool = ...): ...

class Text(_String):
    type: str
    column_type: Any
    column_cast_from: Any
    def convert_to_cache(self, value, record, validate: bool = ...): ...

class Html(_String):
    type: str
    column_type: Any
    def convert_to_column(
        self, value, record, values: Optional[Any] = ..., validate: bool = ...
    ): ...
    def convert_to_cache(self, value, record, validate: bool = ...): ...

class Date(Field[datetime.date]):
    type: str
    column_type: Any
    column_cast_from: Any
    start_of = date_utils.start_of
    end_of = date_utils.end_of
    add: date_utils.add
    subtract: date_utils.subtract
    @staticmethod
    def today(*args) -> datetime.date: ...
    @staticmethod
    def context_today(record, timestamp: Optional[Any] = ...) -> datetime.date: ...
    @staticmethod
    def to_date(value) -> datetime.date: ...
    from_string = to_date
    @staticmethod
    def to_string(value): ...
    def convert_to_cache(self, value, record, validate: bool = ...): ...
    def convert_to_export(self, value, record): ...

class Datetime(Field[datetime.datetime]):
    type: str
    column_type: Any
    column_cast_from: Any
    start_of = date_utils.start_of
    end_of = date_utils.end_of
    add = date_utils.add
    subtract: date_utils.subtract
    @staticmethod
    def now(*args) -> datetime.datetime: ...
    @staticmethod
    def today(*args) -> datetime.datetime: ...
    @staticmethod
    def context_timestamp(record, timestamp) -> datetime.datetime: ...
    @staticmethod
    def to_datetime(value) -> datetime.datetime: ...
    from_string = to_datetime
    @staticmethod
    def to_string(value) -> str: ...
    def convert_to_cache(self, value, record, validate: bool = ...): ...
    def convert_to_export(self, value, record): ...
    def convert_to_display_name(self, value, record): ...

class Binary(Field[bytes]):
    type: str
    @property
    def column_type(self): ...
    def convert_to_column(
        self, value, record, values: Optional[Any] = ..., validate: bool = ...
    ): ...
    def convert_to_cache(self, value, record, validate: bool = ...): ...
    def read(self, records) -> None: ...
    def create(self, record_values) -> None: ...
    def write(self, records, value) -> None: ...

class Selection(Field[str]):
    type: str
    def __init__(self, selection=..., string=..., **kwargs) -> None: ...
    @property
    def column_type(self): ...
    selection: Any
    def get_values(self, env): ...
    def convert_to_column(
        self, value, record, values: Optional[Any] = ..., validate: bool = ...
    ): ...
    def convert_to_cache(self, value, record, validate: bool = ...): ...
    def convert_to_export(self, value, record): ...

class Reference(Selection):
    type: str
    @property
    def column_type(self): ...
    def convert_to_column(
        self, value, record, values: Optional[Any] = ..., validate: bool = ...
    ): ...
    def convert_to_cache(self, value, record, validate: bool = ...): ...
    def convert_to_record(self, value, record): ...
    def convert_to_read(self, value, record, use_name_get: bool = ...): ...
    def convert_to_export(self, value, record): ...
    def convert_to_display_name(self, value, record): ...

class _Relational(Field[BaseModel]):
    relational: bool
    comodel_name: str
    def null(self, record): ...

class Many2one(_Relational):
    type: str
    column_type: Any
    def __init__(self, comodel_name=..., string=..., **kwargs) -> None: ...
    delegate: Any
    ondelete: Any
    def update_db(self, model, columns): ...
    def update_db_column(self, model, column) -> None: ...
    def update_db_foreign_key(self, model, column) -> None: ...
    def convert_to_column(
        self, value, record, values: Optional[Any] = ..., validate: bool = ...
    ): ...
    def convert_to_cache(self, value, record, validate: bool = ...): ...
    def convert_to_record(self, value, record): ...
    def convert_to_read(self, value, record, use_name_get: bool = ...): ...
    def convert_to_write(self, value, record): ...
    def convert_to_export(self, value, record): ...
    def convert_to_display_name(self, value, record): ...
    def convert_to_onchange(self, value, record, names): ...

class _RelationalMultiUpdate:
    record: Any
    field: Any
    value: Any
    def __init__(self, record, field, value) -> None: ...
    def __call__(self): ...

class _RelationalMulti(_Relational):
    def convert_to_cache(self, value, record, validate: bool = ...): ...
    def convert_to_record(self, value, record): ...
    def convert_to_read(self, value, record, use_name_get: bool = ...): ...
    def convert_to_write(self, value, record): ...
    def convert_to_onchange(self, value, record, names): ...
    def convert_to_export(self, value, record): ...
    def convert_to_display_name(self, value, record) -> None: ...

class One2many(_RelationalMulti):
    type: str
    def __init__(
        self, comodel_name=..., inverse_name=..., string=..., **kwargs
    ) -> None: ...
    def convert_to_onchange(self, value, record, names): ...
    def update_db(self, model, columns) -> None: ...
    def read(self, records): ...
    def create(self, record_values) -> None: ...
    def write(self, records, value) -> None: ...

class Many2many(_RelationalMulti):
    type: str
    def __init__(
        self,
        comodel_name=...,
        relation=...,
        column1=...,
        column2=...,
        string=...,
        **kwargs
    ) -> None: ...
    relation: Any
    column1: Any
    column2: Any
    def update_db(self, model, columns): ...
    def update_db_foreign_keys(self, model) -> None: ...
    def read(self, records) -> None: ...
    def create(self, record_values) -> None: ...
    def write(self, records, value) -> None: ...

class Id(Field[int]):
    type: str
    column_type: Any
    def update_db(self, model, columns) -> None: ...
    def __set__(self, record, value) -> None: ...
